<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>Active questions tagged blockchain - Cryptography Stack Exchange</title>
<link>https://crypto.stackexchange.com/questions/tagged/?tagnames=blockchain&amp;sort=active</link>

<item>
<title>Bitcoin Generation [migrated]</title>
<link>https://crypto.stackexchange.com/questions/112159/bitcoin-generation</link>
<guid>https://crypto.stackexchange.com/questions/112159/bitcoin-generation</guid>
<content:encoded><![CDATA[
<div> 关键词：blockchain, parties, bitcoins, initial stage, mining process.

总结:<br>
在区块链网络中，初始阶段每个参与方（如A、B、C和D）持有的比特币数量并不是由他们决定的。新加入的节点在开始时确实可能没有比特币，因为它们通过挖矿过程来获得。挖矿是一种竞争性的过程，参与者使用计算能力解决复杂的数学问题，成功者将获得新区块并从中获得新产生的比特币作为奖励。因此，最初分配的比特币数量是由网络的运行机制和随机的挖矿结果决定的，而不是由用户直接决定。随着时间推移，挖矿和交易会动态地改变各参与方的比特币持有量。 <div>
<p>In a blockchain network with number of parties, how are the number of bitcoins held by each party decided in the initial stage?</p>
<p>Example: If there are 4 parties A,B,C,D who decides/generates the bitcoin held by each of them? I understand that by mining process parties obtain the bitcoins, does it mean initially on joining the network the number of bitcoins is zero?</p>
]]></content:encoded>
<pubDate>2024-06-24T05:39:53Z</pubDate>
<pubDate>2024-06-24T05:54:32Z</pubDate>
</item>
<item>
<title>How to check balance of big number of bitcoin private keys easily? [closed]</title>
<link>https://crypto.stackexchange.com/questions/112143/how-to-check-balance-of-big-number-of-bitcoin-private-keys-easily</link>
<guid>https://crypto.stackexchange.com/questions/112143/how-to-check-balance-of-big-number-of-bitcoin-private-keys-easily</guid>
<content:encoded><![CDATA[
<div> 关键词：86400比特币私钥、4比特币、检查、私钥、本地电脑

总结:<br>
这篇文章的作者拥有86400个比特币私钥，希望能找到至少价值4比特币的那一个。他们手头没有地址，只能通过私钥进行查找。作者寻找一种能批量检查余额的工具，但现有的应用只能一次查看5个。他们愿意提供赏金给有能力帮助的人。文章寻求能够处理大量私钥并检测余额的代码或软件解决方案。 <div>
<p>I have 86400 bitcoin private keys. Within these keys there is high chance of getting 4 btc. I am not jocking.</p>
<p>All keys are important. I have checked some. Example:</p>
<pre><code>e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

686f746a95b6f836d7d70567c302c3f9ebb5ee0def3d1220ee9d4e9f34f5e131
</code></pre>
<p>etc</p>
<p>Is there any easy way to check all 86400 keys and find out desired key which has bitcoin. I am looking for code or ready balance checker script for bitcon.</p>
<p>NB:</p>
<ol>
<li>I have only private keys. No address</li>
<li>As it has balance so I want to check in my local computer</li>
<li>I have found an application whch can check blance but very limited (only 5 at a time)</li>
</ol>
<p>Is there anybody who could help me? If I get bitcoin, I will give you tip.</p>
]]></content:encoded>
<pubDate>2024-06-21T15:19:32Z</pubDate>
<pubDate>2024-06-23T08:38:39Z</pubDate>
</item>
<item>
<title>What is the reason to use blocks in the first place? [closed]</title>
<link>https://crypto.stackexchange.com/questions/111666/what-is-the-reason-to-use-blocks-in-the-first-place</link>
<guid>https://crypto.stackexchange.com/questions/111666/what-is-the-reason-to-use-blocks-in-the-first-place</guid>
<content:encoded><![CDATA[
<div> 关键词：blockchains, blocks, mining, Proof-of-Work (PoW), Proof-of-Stake (PoS)

总结: 区块链中的区块并非仅仅为了挖矿奖励而存在。它们最初设计用来封装交易，提供数据结构的完整性，便于验证和时间戳交易。在Proof-of-Work（PoW）中，区块是构造挑战的关键，通过解决复杂的数学问题来分配矿工奖励。而在Proof-of-Stake（PoS）中，区块用于组织验证者参与共识过程，确定奖励归属。如果没有区块，每个交易都需要独立处理，这将显著增加系统的复杂性和资源消耗。因此，区块是区块链效率和安全性的重要组成部分。 <div>
<p>I am not sure this question is really for this forum. But to be honest, I could not think of a better one.</p>
<p>This question is about blockchains in general. As far as I know, there is no site for general blockchain questions, only specific to ethereum, bitcoin - or this one.</p>
<p>I wonder why blocks are used at all. Is it to define a contained structure to allow for the mining or staking rewards? In other words, for bitcoin and/or Proof-of-Work, to construct the challenge in order to solve it, and assign the mining reward? While for PoS, simply the structure required so a specific reward can be assigned to validators?</p>
<p>I mean, it could just be as easily a chain of transactions without a block right? In which case, each single transaction would have to be &quot;mined&quot;, making the protocol inefficient? Or maybe some other data structure?</p>
<p>Does anyone know fundamental research about this problem? Other data structures used? Thanks.</p>
]]></content:encoded>
<pubDate>2024-05-01T20:28:44Z</pubDate>
<pubDate>2024-05-02T06:55:39Z</pubDate>
</item>
<item>
<title>Can Cryptographic Proofs Directly Attest to Function Call Results?</title>
<link>https://crypto.stackexchange.com/questions/111146/can-cryptographic-proofs-directly-attest-to-function-call-results</link>
<guid>https://crypto.stackexchange.com/questions/111146/can-cryptographic-proofs-directly-attest-to-function-call-results</guid>
<content:encoded><![CDATA[
<div> 关键词：Zero-knowledge proofs (ZKPs), Ethereum NaaS, Function outputs, State transitions, Cryptographic considerations.

总结:
零知识证明（ZKPs）为在远程或不可信环境中验证函数计算结果提供了解决方案。首先，理论上存在限制，但特定类型的函数可能适合生成证明。实践中的过程涉及构造和验证电路，确定输入、输出和上下文状态。加密考虑包括选择合适的证明方法，如 zk-SNARKs 或 zk-STARKs。效率瓶颈包括证明大小、计算时间和电路复杂性。为了保证准确性和效率，需要权衡电路设计和证明的简洁性。在Ethereum NaaS平台上，通过ZKPs，用户可以验证远程服务提供的函数执行结果，而无需透露实际数据，确保数据隐私的同时增强信任。 <div>
<p>In systems where computations are performed in remote or potentially untrusted environments(e.g. Ethereum NaaS providers such as Infura), how can we gain confidence in the accuracy of the results?  Zero-knowledge proofs (ZKPs) provide an intriguing solution for verifying specific aspects of computation.</p>
<p>My focus:</p>
<ul>
<li><strong>Proofs for Function Outputs:</strong> Can we generate a ZKP that directly verifies the output (return value) of a function call, given its inputs and any relevant contextual state?</li>
<li><strong>Beyond State Transitions:</strong>  While ZKPs in blockchains often prove state transitions, I'm interested in the specifics of attesting to a singular function result.</li>
<li><strong>Challenges and Approaches:</strong>  What are the cryptographic considerations, potential circuit design patterns, and trade-offs in constructing proofs for function call outputs?</li>
</ul>
<p>Questions:</p>
<ol>
<li>Are there theoretical limitations to proving arbitrary function results, or are there classes of functions that are well-suited?</li>
<li>How would the process of generating and verifying such a proof look in practice?</li>
<li>What are the potential efficiency bottlenecks (proof size, computation time) to consider?</li>
</ol>
]]></content:encoded>
<pubDate>2024-03-20T10:56:57Z</pubDate>
<pubDate>2024-04-19T22:07:10Z</pubDate>
</item>
<item>
<title>Can I construct a incomplete Merkle Tree without denting its security?</title>
<link>https://crypto.stackexchange.com/questions/111026/can-i-construct-a-incomplete-merkle-tree-without-denting-its-security</link>
<guid>https://crypto.stackexchange.com/questions/111026/can-i-construct-a-incomplete-merkle-tree-without-denting-its-security</guid>
<content:encoded><![CDATA[
<div> 关键词：Merkle树、构造、安全性、完整性、原因。

总结: <br>
Merkle树是一种哈希树数据结构，用于验证数据完整性和来源。在构建Merkle树时，可以选择不同的方式组织节点。文章提出了两种可能的结构：一种是每个分支都有四个子节点（如第一个示例），另一种是部分节点有额外的重复（如第二个示例）。

对于第一个结构，每个节点都有完整的子集，这保证了验证过程的简单性，因为每个路径都可以独立校验。这可能被视为更安全，因为它减少了潜在的篡改点，如果仅修改一个叶子节点，可能会导致整个树的校验失败。

第二个结构虽然看起来冗余，但如果出于某种原因需要高效地存储或处理数据，可能会有其优势，例如减少存储需求或优化某些算法。然而，这种设计增加了潜在的安全风险，因为攻击者只需修改一个重复的节点，可能就能欺骗系统。

总结: <br>
Merkle树结构的选择应考虑安全性与效率之间的权衡。尽管第一个结构提供了更好的安全性，但第二个结构在特定场景下可能更高效。避免使用不完整的树是为了防止通过操纵重复节点进行欺诈，确保数据完整性的可靠性。 <div>
<pre><code>                 Root (Hash01234)
               /                \
        Hash0123               Hash4
        /      \                   
   Hash01      Hash23 
   /   \        /   \   
Hash0  Hash1  Hash2  Hash3 
</code></pre>
<p>Can I construct a Merkle Tree like above instead of creating it like the below?</p>
<pre><code>                 Root (Hash01234444)
               /                    \
        Hash0123                 Hash4444
        /      \                    /     \
   Hash01      Hash23           Hash44     Hash44
   /   \        /   \             /   \
Hash0  Hash1  Hash2  Hash3     Hash4   Hash4
</code></pre>
<ol>
<li>Is one better than the other in terms of Security?</li>
<li>Should I avoid the incomplete tree for any particular reason, if yes, what might those reasons be?</li>
</ol>
]]></content:encoded>
<pubDate>2024-03-09T14:29:56Z</pubDate>
<pubDate>2024-03-10T01:48:12Z</pubDate>
</item>
<item>
<title>Best way to implement public blockchain for IoT?</title>
<link>https://crypto.stackexchange.com/questions/109144/best-way-to-implement-public-blockchain-for-iot</link>
<guid>https://crypto.stackexchange.com/questions/109144/best-way-to-implement-public-blockchain-for-iot</guid>
<content:encoded><![CDATA[

<p>I'm attempting to build a blockchain network of IoT devices that would allow public access such that any person around the world could push data to it and there would be an immutable record of all data pledged to the network. The validity of the data or the trust of the client isn't important, but keeping a permanent ledger of all activity is. Reducing centralization is also important for this particular application, hence the need for blockchain. What is the best way to go about creating such a system? What consensus algorithm is best for this application? Proof of work seems like overkill. Proof of stake? Would proof of authority be best?</p>
<p>Thanks!</p>
]]></content:encoded>
<pubDate>2023-12-21T16:16:51Z</pubDate>
<pubDate>2023-12-21T16:16:51Z</pubDate>
</item>
<item>
<title>Can blockchain be considered a cryptographic primitive?</title>
<link>https://crypto.stackexchange.com/questions/107503/can-blockchain-be-considered-a-cryptographic-primitive</link>
<guid>https://crypto.stackexchange.com/questions/107503/can-blockchain-be-considered-a-cryptographic-primitive</guid>
<content:encoded><![CDATA[

<p>This might be a silly question. But since more and more people simply use public blockchains as a secure ledger to store mutually agreed information to secure their high level applications, could we abstract blockchains as a secure ledger primitive that has the following properties:</p>
<ul>
<li><strong>Append-only</strong></li>
<li><strong>Tamper-proof</strong> (by minority of the participants)</li>
<li><strong>Universally consistent view</strong> (under certain synchrony assumptions),</li>
</ul>
<p>of course which applies to secure permissionless blockchains only. My question is, what prevents an abstracted secure blockchain to be defined/considered a cryptographic primitive? Does it need a paper or standard document that presents a formal definition and a security proof, or are there some deeper rules basically says primitives can only be very low level fundamental constructions?</p>
<p>This comes from reading recent advancements of <a href="https://eprint.iacr.org/2021/453" rel="nofollow noreferrer">transparency logs</a> and makes me realize the border between blockchain and secure public transparency logs (such as a distributedly maintained append-only merkle tree) are getting blurred.</p>
<p><strong>Edit Nov. 2023:</strong> As @Paul suggests, this is a useful discussion -&gt; <a href="https://crypto.stackexchange.com/questions/39735/whats-a-cryptographic-primitive-really">What's a cryptographic primitive, really?</a></p>
]]></content:encoded>
<pubDate>2023-08-04T02:33:50Z</pubDate>
<pubDate>2023-11-27T03:34:05Z</pubDate>
</item>
<item>
<title>How can the validity of signatures in layer-2 transactions be proven in zk-rollup?</title>
<link>https://crypto.stackexchange.com/questions/107824/how-can-the-validity-of-signatures-in-layer-2-transactions-be-proven-in-zk-rollu</link>
<guid>https://crypto.stackexchange.com/questions/107824/how-can-the-validity-of-signatures-in-layer-2-transactions-be-proven-in-zk-rollu</guid>
<content:encoded><![CDATA[

<p>I have many questions about the details of using zk-SNARK technology in zk-rollup：</p>
<ol>
<li>How can the validity of signatures in layer-2 transactions be proven in zk-rollup?</li>
<li>In zk-rollup, is a single large zero-knowledge proof circuit used to prove the validity of signatures for a batch of transactions, or is it separately proving the validity of each signature and then aggregating these proofs?</li>
<li>Are there any publicly available papers or tutorials that explain the details of proof signature validity in zk-rollup? Reading the zk-rollup project code is too challenging for me.</li>
</ol>
]]></content:encoded>
<pubDate>2023-09-02T11:05:38Z</pubDate>
<pubDate>2023-09-02T11:05:38Z</pubDate>
</item>
<item>
<title>Authenticate the users (in telegram bot) without storing user ids</title>
<link>https://crypto.stackexchange.com/questions/107611/authenticate-the-users-in-telegram-bot-without-storing-user-ids</link>
<guid>https://crypto.stackexchange.com/questions/107611/authenticate-the-users-in-telegram-bot-without-storing-user-ids</guid>
<content:encoded><![CDATA[

<p>Might be a bit weird but interesting scenario: I have a telegram bot and I need to authenticate users but I don't want to store any user data(at least openly).</p>
<p>So here's a breakdown:</p>
<ol start="0">
<li>I need to prove that the user has access to the bot. So there's a &quot;timeframe&quot; variable, an extra piece of information which might be helpful.</li>
<li>The infrastructure can not be trusted so the db can't store any user data.</li>
<li>Encryption is not an option since there's no way to keep the key secure (can store it in the memory, but what to do in case of restart?).</li>
<li>Hashing is hard cause telegram sends user_id and user names in the meta. But unfortunately these are well-known (ids are just sequential numbers 32bit and usernames can be changed arbitrarily). So this is prone to brute force attacks. Bcrypt might be a solution but I thought that there might be better solutions.</li>
<li>One option is that user can send a unique string(password). But this is not always possible in my scenario cause some of the users are IoT devices and they are hard to manipulate.</li>
</ol>
<p>I know that the solution revolves around hashing but how can I make it really hard to brute force?
The original field is 32 bit but it gets really small when you factor in the actually taken ids (which is probably in the order of 100 million).</p>
<p>That sounds impossible but I have the &quot;timeframe&quot; field. Since the bot runs continuously is there a <strong>blockchain-like solution</strong> where it will rehash some stored data every now and then and <strong>older data will be obscured</strong> and exponentially harder to brute force?</p>
]]></content:encoded>
<pubDate>2023-08-14T04:35:44Z</pubDate>
<pubDate>2023-08-14T04:39:43Z</pubDate>
</item>
<item>
<title>The specific nature of a 51% attack - in relation to a multiple choice question that I was marked as incorrect on</title>
<link>https://crypto.stackexchange.com/questions/107191/the-specific-nature-of-a-51-attack-in-relation-to-a-multiple-choice-question</link>
<guid>https://crypto.stackexchange.com/questions/107191/the-specific-nature-of-a-51-attack-in-relation-to-a-multiple-choice-question</guid>
<content:encoded><![CDATA[

<p>In a course I'm taking the following question came up:</p>
<blockquote>
<pre><code>A 51% attack means:

  A. 51% of the nodes are bots 

  B. 51% of the nodes are hackers
 
  C. 51% of the nodes are offline or disabled 

  D. 51% of the nodes agree on something
</code></pre>
</blockquote>
<p><strong>I had answered D, but the correct answer was given as B.</strong></p>
<p>As far as I am aware, I believe that it was required (in a proof of stake system) to acquire 51% of the staked coins. From my understanding, a group of billionaires could get together to acquire said value, and as such, I answered D - 51% of the nodes agree on something, which while is not the way I would choose to answer it if I had the choice, I thought was more accurate than the hacker answer.</p>
<p>I'd think the right information should be: &quot;A 51% attack is when one entity (which may comprise sub-entities) controls 51% of the network's consensus mechanism (be it mining power or value staked), enabling them to manipulate the blockchain.&quot; This answer does not contain the term &quot;nodes&quot; nor does it contain the term &quot;hackers&quot;.</p>
<p>I tried to talk to the course-coordinator about this and he told me to do more research. The only way for me to do that, due to the specificity of the question, is to ask the opinions of learned people. If there is a better forum for me to post this on, please point me toward it.</p>
]]></content:encoded>
<pubDate>2023-07-12T07:10:28Z</pubDate>
<pubDate>2023-07-12T09:18:53Z</pubDate>
</item>
<item>
<title>Verification in Bulletproof commitment scheme</title>
<link>https://crypto.stackexchange.com/questions/106828/verification-in-bulletproof-commitment-scheme</link>
<guid>https://crypto.stackexchange.com/questions/106828/verification-in-bulletproof-commitment-scheme</guid>
<content:encoded><![CDATA[

<p>I am reviewing the ZKP course, represented by the university of Berkley (<a href="https://zk-learning.org/" rel="nofollow noreferrer">https://zk-learning.org/</a>). In pages 44 of lecture 6 that is attached below (<a href="https://zk-learning.org/assets/lecture6.pdf" rel="nofollow noreferrer">https://zk-learning.org/assets/lecture6.pdf</a>), the instructor explains the Poly-commitment based on Bulletproofs scheme.</p>
<p>I am a little confused that why the verifier compute com', g', and v' when it just checks v=v_L+v_R u^(d/2). Does the verifer need com' and g' for the last round? If so, how can it use them and what is the extra verification in the last round.</p>
<p><a href="https://i.sstatic.net/scBXa.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.sstatic.net/scBXa.png" /></a></p>
]]></content:encoded>
<pubDate>2023-06-13T06:16:42Z</pubDate>
<pubDate>2023-06-13T19:20:17Z</pubDate>
</item>

</channel>
</rss>