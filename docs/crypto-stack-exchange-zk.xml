<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>Active questions tagged zero-knowledge-proofs - Cryptography Stack Exchange</title>
<link>https://crypto.stackexchange.com/questions/tagged/?tagnames=zero-knowledge-proofs&amp;sort=active</link>

<item>
<title>Zero-Knowledge in PLONK paper in prover round 3. Shouldn't the degree be less than n?</title>
<link>https://crypto.stackexchange.com/questions/112195/zero-knowledge-in-plonk-paper-in-prover-round-3-shouldnt-the-degree-be-less-th</link>
<guid>https://crypto.stackexchange.com/questions/112195/zero-knowledge-in-plonk-paper-in-prover-round-3-shouldnt-the-degree-be-less-th</guid>
<content:encoded><![CDATA[
<div> 关键词：prover算法、round 3、quotient polynomial、degree < n、blinding terms、commitment、trusted setup、variables。

总结:<br>
在论文的第29页，prover算法的第三轮中，将商多项式划分为三个度数小于n的子多项式。然而，当添加盲化项时，会涉及到$X^n$。问题在于，如果只在可信设置阶段使用了n个变量，如何进行这一 commitment（承诺）操作？这可能暗示着需要扩展原有的变量或者利用某种巧妙的方法来处理高阶项，但具体实现细节未在文中详述。 <div>
<p>From the <a href="https://eprint.iacr.org/2019/953.pdf" rel="nofollow noreferrer">PLONK</a> paper.</p>
<p>On page 29, in the prover algorithm round 3, we divide the quotient polynomial into three polynomials of degree &lt; n. But when we add the blinding terms we add <span class="math-container">$X^n$</span>.</p>
<p><a href="https://i.sstatic.net/gw5RXdzI.png" rel="nofollow noreferrer"><img alt="Part of the equation in PLONK paper" src="https://i.sstatic.net/gw5RXdzI.png" /></a></p>
<p>The question is, how do we commit to this, if we only have n variables in the trusted setup?</p>
]]></content:encoded>
<pubDate>2024-06-27T06:35:23Z</pubDate>
<pubDate>2024-07-01T12:08:07Z</pubDate>
</item>
<item>
<title>Why is the first coefficient set to 1 in both GGPR13 &amp; Groth16 SNARKS?</title>
<link>https://crypto.stackexchange.com/questions/112203/why-is-the-first-coefficient-set-to-1-in-both-ggpr13-groth16-snarks</link>
<guid>https://crypto.stackexchange.com/questions/112203/why-is-the-first-coefficient-set-to-1-in-both-ggpr13-groth16-snarks</guid>
<content:encoded><![CDATA[
<div> 关键词：$a_0$, $a_k$, $v_0$, $w_0$, $y_0$

总结:<br>
在代数方程中，将$v_0, w_0, y_0$项独立出来并将$a_0$设为1的做法常见于简化表达式。这样做可以使方程更加清晰，因为$a_0$通常代表常数项或基础元素，将其分离便于后续处理。在Groth16的相关解释中，可能出于类似的目的省略了这个步骤，但实际应用时可以灵活选择是否显式设置$a_0=1$。这种处理方式使得变量集中，有助于理解和计算。 <div>
<p>From <a href="https://eprint.iacr.org/2012/215.pdf" rel="nofollow noreferrer">GGPR13</a></p>
<p>Section 7.1, Page 42</p>
<blockquote>
<p>(<span class="math-container">$v_0(x) +\sum_{k=1}^m a_k \cdot v_k(x)) \cdot (w_0(x) +\sum_{k=1}^m a_k \cdot w_k(x)) - (y_0(x) +\sum_{k=1}^m a_k \cdot y_k(x))$</span></p>
</blockquote>
<p>If you notice, the term <span class="math-container">$a_k$</span> is there only for <span class="math-container">$k = 1$</span> to <span class="math-container">$m$</span>. The first terms <span class="math-container">$v_0, w_0, y_0$</span> have been brought outside the summation - i.e. equivalent to setting <span class="math-container">$a_0 = 1$</span></p>
<p>Likewise in <a href="https://eprint.iacr.org/2016/260.pdf" rel="nofollow noreferrer">Groth16</a></p>
<p>Section 2.3, Page 9</p>
<blockquote>
<p>The equations will be over <strong><span class="math-container">$a_0 = 1$</span></strong> and variables <span class="math-container">$a_1, \dots a_m \in F$</span> and be of the form</p>
</blockquote>
<blockquote>
<p><span class="math-container">$\sum a_iu_{i,q} \cdot \sum a_iv_{i,q} = \sum a_iw_{i,q}$</span></p>
</blockquote>
<p>Here they don't bring the first term out with no co-efficient but specify <span class="math-container">$a_0 = 1$</span></p>
<p>I understand that <span class="math-container">$a_0$</span> can be made 1 by dividing all other coefficients with the previous <span class="math-container">$a_0$</span> but why is it done?</p>
<hr />
<p>Also, in site or blog which explains Groth16 - for e.g. <a href="https://medium.com/coinmonks/under-the-hood-of-zksnark-groth16-protocol-part-3-9d3e0934607b" rel="nofollow noreferrer">Groth16 under the hood</a>, I can't find the examples actually enforcing this <span class="math-container">$a_0=1$</span> at all - they just seem to ignore this.</p>
]]></content:encoded>
<pubDate>2024-06-28T08:38:55Z</pubDate>
<pubDate>2024-07-01T10:23:05Z</pubDate>
</item>
<item>
<title>Why are the expressions divided by 2 random elements $\gamma$ &amp; $\delta$ in Groth16?</title>
<link>https://crypto.stackexchange.com/questions/112206/why-are-the-expressions-divided-by-2-random-elements-gamma-delta-in-grot</link>
<guid>https://crypto.stackexchange.com/questions/112206/why-are-the-expressions-divided-by-2-random-elements-gamma-delta-in-grot</guid>
<content:encoded><![CDATA[
<div> 关键词：prover, verifier, verification equation, independence, mixing and matching

总结: 在第14页，证明者计算了$C$的表达式，其中包含了多个项。验证者公式中，有两个后续项与第一项相乘，即$\frac{\sum_{i=0}^{l} a_i (\beta u_i(x) + \alpha v_i(x) + w_i(x))}{\gamma}$乘以$\gamma$和$C$乘以$\delta$。第15页解释说，引入$\gamma$和$\delta$是为了确保这两个后项独立于第一个乘积，防止在验证等式中意外地将属于不同部分的元素混淆。这样做是为了保护系统的安全性，防止可能的错误匹配攻击或欺诈行为。

通过将这些项分别除以它们，验证过程更加清晰，确保每个部分的计算都是独立进行的，从而增强了验证的正确性和系统的安全性。 <div>
<p>In <a href="https://eprint.iacr.org/2016/260.pdf" rel="nofollow noreferrer">Groth16</a> Page 14</p>
<p>The prover does</p>
<p><span class="math-container">$C = \frac {\sum_{i = l+1}^m a_i ( \beta u_i(x) + \alpha v_i(x) + w_i(x)) + h(x)t(x)}{\delta} + As + r\beta − rs\delta$</span></p>
<p>And the verifier</p>
<p><span class="math-container">$A \cdot B = \alpha \cdot \beta + \frac {\sum_{i=0}^{l} a_i (\beta u_i(x) + \alpha v_i(x) + w_i(x)) }{\gamma} \cdot \gamma + C \cdot \delta$</span></p>
<p>On Page 15, an explanation is given</p>
<blockquote>
<p>The role of <span class="math-container">$\gamma$</span> and <span class="math-container">$\delta$</span> is to make the two latter products of the verification equation independent from the first product, by dividing the left factors with <span class="math-container">$\gamma$</span> and <span class="math-container">$\delta$</span> respectively. This prevents mixing and matching of elements intended for different products in the verification equation.</p>
</blockquote>
<p>I am unable to understand this - what does it mean &quot;two latter products of the verification equation independent from the first product&quot;</p>
<p>What is the mixing &amp; matching being talked about &amp; what kind of attack is prevented by doing this?</p>
]]></content:encoded>
<pubDate>2024-06-28T11:08:09Z</pubDate>
<pubDate>2024-06-30T12:32:07Z</pubDate>
</item>
<item>
<title>Understanding Knowledge of Exponent use in Groth16</title>
<link>https://crypto.stackexchange.com/questions/112196/understanding-knowledge-of-exponent-use-in-groth16</link>
<guid>https://crypto.stackexchange.com/questions/112196/understanding-knowledge-of-exponent-use-in-groth16</guid>
<content:encoded><![CDATA[
<div> 关键词：Exponent/Coefficient Test, zkSNARK, Groth16 Protocol, Elliptic Curve Pairings, Polynomial Shift

总结:<br>
zkSNARK中的Exponent/Coefficient Test用于验证点的线性关系，确保接收的点是基于原始点通过特定缩放因子计算得出。在Groth16协议中，有两个不同的缩放因子（$\alpha$和$\beta$），通过将多项式加上这些因子，验证者实际上在检查新的多项式是否正确地受到了这些因子的影响。虽然文章没有直接列出类似$e([L'], G) = e([L'], α)$的检查，但这种验证是隐含在多项式乘法和配对检查中的，因为它们确保了新表达式的正确性。

Groth16的方法与Petkus方式相比，可能提供了效率或简洁性的优势，但具体优势取决于应用场景和性能需求。这里的重点是理解如何通过配对检查来实现多项式的隐式缩放验证。 <div>
<p>I understand the basic Knowledge of Exponent/Coefficient Test.
Alice sends 2 elliptic curve points <span class="math-container">$x$</span> &amp; <span class="math-container">$y$</span> to Bob such that <span class="math-container">$y = \alpha \cdot x$</span>
If Bob is able to send back 2 points <span class="math-container">$x'$</span> &amp; <span class="math-container">$y'$</span> such that <span class="math-container">$y' = \alpha \cdot x'$</span>, then w.h.p., Bob has created those 2 points using the original <span class="math-container">$x$</span> &amp; <span class="math-container">$y$</span>.</p>
<hr />
<p>Now <a href="https://arxiv.org/pdf/1906.07221" rel="nofollow noreferrer">Petkus's Explainer</a> on a general zkSNARK uses this to restrict the polynomials sent by prover as shown below</p>
<p>Consider the QAP, <span class="math-container">$L(x) \cdot R(x) = O(x) + H(x) \cdot T(x)$</span></p>
<p>Let <span class="math-container">$[F]$</span> denote commitment of <span class="math-container">$F(x)$</span>. Let [L'] denote commitment of polynomial shifted by <span class="math-container">$\alpha$</span> i.e <span class="math-container">$[F']$</span> is the commitment of <span class="math-container">$\alpha F(x)$</span></p>
<p>Prover sends <span class="math-container">$[L], [R], [O], [H]$</span> &amp; also <span class="math-container">$[L'], [R'], [O'']$</span> to Verifier.</p>
<p>Verifier checks the following using Elliptic Curve Pairings</p>
<ol>
<li><p><span class="math-container">$e([L], [R]) = e([T],[H]). e([O],G)$</span></p>
</li>
<li><p>Knowledge of Co-efficient Check</p>
</li>
</ol>
<ul>
<li><span class="math-container">$e([L'], G) = e([L'], α)$</span></li>
<li><span class="math-container">$e([R'], G) = e([R'], α)$</span></li>
<li><span class="math-container">$e([O'], G) = e([O'], α)$</span></li>
</ul>
<hr />
<p>Now, I am not able to corelate this with how the Groth16 Protocol uses it.</p>
<p>In Groth16, they have 2 different shift scalars <span class="math-container">$\alpha$</span> &amp; <span class="math-container">$\beta$</span>.</p>
<p>Then, they do</p>
<p><span class="math-container">$L' = L + \alpha$</span><br />
<span class="math-container">$R' = R + \beta$</span></p>
<p>From this, you can trivially derive a new equation to check</p>
<p><span class="math-container">$L’R’ = \alpha \beta + \beta L + \alpha R + O + HZ$</span></p>
<p>And they then proceed to verify this equation using pairings (I understand the pairing check used to verify this).</p>
<p>I don't see any check similar to <span class="math-container">$e([L'], G) = e([L'], α)$</span> etc where you check if the shifted Polynomial is correctly shifted by <span class="math-container">$\alpha$</span> from the original polynomial.</p>
<p>I am assuming this is implicit in the check, but I am unable to figure out how.
Also, is there an advantage in doing it this way over Petkus's way?</p>
]]></content:encoded>
<pubDate>2024-06-27T09:57:21Z</pubDate>
<pubDate>2024-06-29T11:48:00Z</pubDate>
</item>
<item>
<title>A zero-knowledge proof for ElGamal signature</title>
<link>https://crypto.stackexchange.com/questions/112185/a-zero-knowledge-proof-for-elgamal-signature</link>
<guid>https://crypto.stackexchange.com/questions/112185/a-zero-knowledge-proof-for-elgamal-signature</guid>
<content:encoded><![CDATA[
<div> 关键词：零知识证明、ElGamal签名、证明、公钥、关系

总结:<br>
在将零知识证明添加到ElGamal签名中，你提到构造了一个证明$\pi$，其中包含$(r,s), y, m, x, k$等值。关系$R$包括三个条件：消息相关性、公钥正确性和秘密解的计算。然而，你指出无法证明第三个条件（关于$s$的计算）。为了解决这个问题，通常会使用零知识证明技术来隐藏这部分信息，确保验证者仅确认前两个条件，同时保证了签名的有效性和隐藏性。具体步骤可能涉及构造一个零知识证明，让证明者能够安全地证明他们知道$s$满足第三个条件，而无需揭示其实际值。 <div>
<p>If I want to add zero-knowledge proof to the ElGamal signature, is it reasonable to write that?</p>
<p><span class="math-container">$$
\pi \gets \operatorname{NIZK.Prove}\bigl(u=((r,s),y,m),w=(x,k)\bigr)
$$</span></p>
<p><span class="math-container">$$
R=\{u,w:g^{H(m)}=y^rr^s \bmod p \bigwedge r=g^k\bmod p \bigwedge s=(H(m)-xr)k^{-1}\bmod (p-1)\}
$$</span></p>
<p>But I can't prove one and three parts of <span class="math-container">$R$</span>, so how do I prove this part?</p>
]]></content:encoded>
<pubDate>2024-06-26T02:17:41Z</pubDate>
<pubDate>2024-06-26T10:59:44Z</pubDate>
</item>
<item>
<title>Zero-Knowledge Proof of a number being generated "randomly" (similar to a dice roll)</title>
<link>https://crypto.stackexchange.com/questions/112138/zero-knowledge-proof-of-a-number-being-generated-randomly-similar-to-a-dice-r</link>
<guid>https://crypto.stackexchange.com/questions/112138/zero-knowledge-proof-of-a-number-being-generated-randomly-similar-to-a-dice-r</guid>
<content:encoded><![CDATA[

<p>If party1 asks other parties to give a random number, for simplicity, say in a range from 1 to 6 (like in a dice). Is it possible for party1 to ensure that the number received is in a given range and is chosen randomly by the providing party without revealing the number? Something like a dice roll. Providing party commits to the number. The commitments are opened at the end of the game.</p>
<p>How to prevent all/malicious parties to simply always giving the same number, say 1, or a sequentially increasing number, say 1, 2.. claiming the number is between the asked range.</p>
<p>The received number should ensure following
(1) number is in a given range
(2) number is chosen randomly</p>
<p>Is there a way to enforce and to verify that the number is chosen randomly?</p>
]]></content:encoded>
<pubDate>2024-06-21T04:30:16Z</pubDate>
<pubDate>2024-06-21T04:30:16Z</pubDate>
</item>
<item>
<title>Mental Poker: Can the shuffle of the deck be done Publicaly by a single player at the start of the game</title>
<link>https://crypto.stackexchange.com/questions/112131/mental-poker-can-the-shuffle-of-the-deck-be-done-publicaly-by-a-single-player-a</link>
<guid>https://crypto.stackexchange.com/questions/112131/mental-poker-can-the-shuffle-of-the-deck-be-done-publicaly-by-a-single-player-a</guid>
<content:encoded><![CDATA[

<p>Ref: <a href="https://www.researchgate.net/profile/Igor-Shparlinski/publication/220963091_Periodic_Sequences_with_Maximal_Linear_Complexity_and_Almost_Maximal_k-Error_Linear_Complexity/links/0c96052af8b2672aae000000/Periodic-Sequences-with-Maximal-Linear-Complexity-and-Almost-Maximal-k-Error-Linear-Complexity.pdf#page=380" rel="nofollow noreferrer">Mental Poker Revisited</a> by Barnett and Smart.</p>
<p>I am looking at mental poker problem.</p>
<p>Generally, the shuffling process is done by a single player who starts the game and not by all players.</p>
<p>But, in the <a href="https://www.researchgate.net/profile/Igor-Shparlinski/publication/220963091_Periodic_Sequences_with_Maximal_Linear_Complexity_and_Almost_Maximal_k-Error_Linear_Complexity/links/0c96052af8b2672aae000000/Periodic-Sequences-with-Maximal-Linear-Complexity-and-Almost-Maximal-k-Error-Linear-Complexity.pdf#page=380" rel="nofollow noreferrer">paper</a>, while discussing the operation of shuffling the deck (Section 4.2), the author mentions the shuffle-encrypt by the starting single player as the &quot;Privately Mask&quot; operation which means the cards are shuffled only for others and not for the first player. The author mentions that for cards to be shuffled for all the players, cards have to be &quot;Publicaly Masked&quot; which involves everybody else to remask (reencrypt) all the cards. But, this is not what happens in actual play - in actual play, only the first person shuffles the deck.</p>
<p>Can a single player publicaly shuffle the deck? Can it be done by letting the first player attaching some zero-knowledge proof of that? But, then what proof would it be?</p>
<p>This is important in my scenario since players join gradually and only a single player starts the game and others keep joining gradually later on. Before the second player joins the game, the cards should be in shuffled order which means the first player should not know which card is at which index.</p>
<p>Is there a scheme for this? How can it be done?</p>
]]></content:encoded>
<pubDate>2024-06-20T07:11:46Z</pubDate>
<pubDate>2024-06-20T08:34:22Z</pubDate>
</item>
<item>
<title>Special PoK verifying signature of a hidden message</title>
<link>https://crypto.stackexchange.com/questions/112115/special-pok-verifying-signature-of-a-hidden-message</link>
<guid>https://crypto.stackexchange.com/questions/112115/special-pok-verifying-signature-of-a-hidden-message</guid>
<content:encoded><![CDATA[

<p>Alice has a hidden message <span class="math-container">$g^{a \alpha}=(g^a)^\alpha$</span> where <span class="math-container">$g^a$</span> is the message, and a signature <span class="math-container">$s$</span> on <span class="math-container">$g^a$</span> from Charlie. She sends both <span class="math-container">$g^{a \alpha}$</span> and <span class="math-container">$s$</span> to Bob. She later wants to prove to Bob that she knows an <span class="math-container">$\alpha$</span> such that <span class="math-container">$s$</span> is a signature of <span class="math-container">$(g^{\alpha a})^{\alpha^{-1}}$</span> without disclosing neither <span class="math-container">$g^a$</span> nor <span class="math-container">$\alpha$</span>.</p>
<p>Does such a PoK exist?</p>
]]></content:encoded>
<pubDate>2024-06-17T18:44:28Z</pubDate>
<pubDate>2024-06-18T07:15:00Z</pubDate>
</item>
<item>
<title>Can interactive zero-knowledge proof systems be implemented using secure two-party computation?</title>
<link>https://crypto.stackexchange.com/questions/93719/can-interactive-zero-knowledge-proof-systems-be-implemented-using-secure-two-par</link>
<guid>https://crypto.stackexchange.com/questions/93719/can-interactive-zero-knowledge-proof-systems-be-implemented-using-secure-two-par</guid>
<content:encoded><![CDATA[

<p>I am defining multi-party computation using the real-ideal paradigm (see <a href="https://www.cs.virginia.edu/%7Eevans/pragmaticmpc/pragmaticmpc.pdf" rel="nofollow noreferrer"><em>A Pragmatic Introduction to Secure Multi-Party Computation</em></a>).
That is, for any successful attack on an MPC protocol in the real world, there exists a simulator that carries out this attack successfully in the ideal world. It follows that security in the real world must be equivalent to security in the ideal world.</p>
<p>I am defining interactive zero-knowledge proof systems for a language <span class="math-container">$L$</span> using the original definition from <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.419.8132&amp;rep=rep1&amp;type=pdf" rel="nofollow noreferrer"><em>The Knowledge Complexity of Interactive Proof Systems</em></a>. That is, a pair <span class="math-container">$(A, B)$</span> of interactive Turing machines must fulfill</p>
<ol>
<li>Completeness: given <span class="math-container">$x \in L$</span>, <span class="math-container">$B$</span> accepts with very high probability;</li>
<li>Soundness: given any prover <span class="math-container">$A'$</span> and <span class="math-container">$x \not\in L$</span> passed into <span class="math-container">$(A', B)$</span>, <span class="math-container">$B$</span> accepts with very low probability;</li>
<li>Zero-Knowledge: there exists a probabilistic polynomial-time simulator that can simulate the entire exchange of messages between <span class="math-container">$A$</span> and <span class="math-container">$B$</span> for any input <span class="math-container">$x \in L$</span>.</li>
</ol>
<p>Now, the paper <a href="https://web.cs.ucla.edu/%7Erafail/PUBLIC/77.pdf" rel="nofollow noreferrer"><em>Zero-Knowledge from Secure Multiparty Computation</em></a> mentions the following:</p>
<blockquote>
<p>Zero-knowledge protocols can be viewed as a special case of secure two-party
computation, where the function verifies the validity of a witness held by the prover.</p>
</blockquote>
<p>That is, given <span class="math-container">$L \in \mathcal{NP}$</span>, there exists an algorithm <span class="math-container">$A$</span> such that <span class="math-container">$x \in L \iff \exists w\colon A(x, w) = 1$</span> (definition of <span class="math-container">$\mathcal{NP}$</span>).
One party <span class="math-container">$P_1$</span> acts as the prover, another <span class="math-container">$P_2$</span> as the verifier.
<span class="math-container">$P_1$</span> knows <span class="math-container">$x$</span> and <span class="math-container">$w$</span>, <span class="math-container">$P_2$</span> knows only <span class="math-container">$x$</span>.
They execute <span class="math-container">$A(x, w)$</span> together to determine whether <span class="math-container">$x \in L$</span> or not.</p>
<p>Clearly, <span class="math-container">$w$</span> is not revealed to the verifier <span class="math-container">$P_2$</span> due to the MPC protocol.
However, is the definition of zero-knowledge not more general?
If the prover <span class="math-container">$P_1$</span> sent, for some reason, the solution to some instance of an <span class="math-container">$\mathcal{NP}$</span>-complete problem<sup>1</sup>, no polynomial-time simulator could simulate this assuming <span class="math-container">$\mathcal{P} \neq \mathcal{NP}$</span>.
The created proof system would not be zero-knowledge.</p>
<p>So, given that an MPC protocol could exchange non-simulatable messages, an MPC protocol cannot actually be used to implement a zero-knowledge proof system for some language <span class="math-container">$L \in \mathcal{NP}$</span>, can it?</p>
<hr />
<p><sup>1</sup> The solution can be made dependent on <span class="math-container">$x$</span> such that it is not constant and thus easily simulatable.</p>
]]></content:encoded>
<pubDate>2021-08-24T20:31:36Z</pubDate>
<pubDate>2024-06-18T05:55:44Z</pubDate>
</item>
<item>
<title>Zero-Knowledge Proof of Encryption with a Specific Key</title>
<link>https://crypto.stackexchange.com/questions/108009/zero-knowledge-proof-of-encryption-with-a-specific-key</link>
<guid>https://crypto.stackexchange.com/questions/108009/zero-knowledge-proof-of-encryption-with-a-specific-key</guid>
<content:encoded><![CDATA[

<p><strong>Short version:</strong></p>
<p>Given a hash of a plaintext, a public key, and a ciphertext (but not knowing the original plaintext), is there any way to verify that the ciphertext is the plaintext after being encrypted with the public key?</p>
<p><strong>Long version:</strong></p>
<p>I'd like to develop a broker that can pass to a recipient a message of which it knows the ciphertext and the plaintext's hash (but not the plaintext itself), but will only do so if it can be confident that the ciphertext is indeed the original message that was encrypted using the recipient's public key (which it knows).</p>
<p>This is somewhat similar to proxy re-encryption, except that the proxy is only verifying the public key of the re-encryption, not actually doing the re-encryption. Perhaps there's a way to do this through holomorphic encryption?</p>
<p>As far as I'm aware, there is currently no way to do this. But, advancements in zero-knowledge proofs and other cryptographic tricks are happening so quickly that I wanted to check and see if this could be done before giving up on it.</p>
<p>You may ask &quot;why doesn't the recipient just try to decrypt it and verify it against the cipher text hash?&quot; That is not feasible in this use case, because other actions are tied to the broker forwarding messages and they shouldn't happen unless it's actually a valid message. i.e. there are good reasons that the broker cannot forward an invalid message.</p>
]]></content:encoded>
<pubDate>2023-09-18T21:54:58Z</pubDate>
<pubDate>2024-06-18T02:03:25Z</pubDate>
</item>
<item>
<title>Efficient NOT in set proof?</title>
<link>https://crypto.stackexchange.com/questions/112108/efficient-not-in-set-proof</link>
<guid>https://crypto.stackexchange.com/questions/112108/efficient-not-in-set-proof</guid>
<content:encoded><![CDATA[

<p>I am looking for a solution for a very specific problem, I have one, but I am not statisfied with it and it feels there must be a much more efficient way to do this.</p>
<p>I have a hashed value of 256 bits. I want to proof if it is NOT part of a given set. IE a ban list. The solution must be unforgable given some commited value.</p>
<p>The solution I have now is pretty straight forward. I use balanced merkle tree with a depth of 256 with a poseidon hash function (128 bit, I want to use it in ZK).
I intialized the tree with 0 values, which makes it easy to pre-compute the initial merkle root.
When I want 'ban' a value. I use the 256bit value as the leaf index and flip the value from 0 to 1 and then recalculate the root.
A proof that a certain value is 0 is easily computed but the merkle proof is rather large (256 * 128 ~= 4kb) and takes quite some hashing to compute, especially in ZK.
However, the main issue I have is that the values being 'banned' are random 256 bit numbers. So as I ban them I need to store roughly the same amount (4kb) per banned 256bit value.
This method needs to work for billions of values so it adds up.</p>
<p>Since I only need to 'bitflip' a value being true or false it feels like there must be some more efficient solution. I explored some but they seem to increase the proof size significantly.</p>
<p>Note that I am the party that generates the possible values to be banned!</p>
<p>With that knowledge I looked into bloomfilters, since I can add nonces to prevent bloomfilter collisions, however, to gain a reasonable amount I would need a sizable bloomfilter.
For the storage requirements this is a very very good option, and might be included as part merkle tree for speedier processing. But the significantly increases the size requirement of the proof
as I would need to include the entire bloomfilter as part of the proof (note this is in ZK, so size really matters).</p>
<p>I have also looked at Ethereums Patricia Merkle Trie but that is not efficient either. Their new Verkle tree approach based on pedersen commitmets seems promising but it seems to be focused on some value being part of a
larger state tree, ie address lookups and is mainly to proof something IS part of a set, however, I want to proof something is NOT part of a set (maybe I can compute it differently?).</p>
<p>The solution I have now works, but I was wondering if there are some other methods known that can do this more efficiently with smaller more efficient proofs AND lower overhead requirements on the prover (ie knowning the state of merkle tree)</p>
]]></content:encoded>
<pubDate>2024-06-16T20:31:26Z</pubDate>
<pubDate>2024-06-16T20:31:26Z</pubDate>
</item>
<item>
<title>What is a rank-1 constraint system?</title>
<link>https://crypto.stackexchange.com/questions/67857/what-is-a-rank-1-constraint-system</link>
<guid>https://crypto.stackexchange.com/questions/67857/what-is-a-rank-1-constraint-system</guid>
<content:encoded><![CDATA[

<p>Why not rank-2 constraint system or rank-3 constraint system?</p>

<p>How do rank-1 constraint systems link to circuits?</p>
]]></content:encoded>
<pubDate>2019-03-07T23:39:32Z</pubDate>
<pubDate>2024-06-15T18:52:16Z</pubDate>
</item>
<item>
<title>Can a Sigma protocol be transformed into a signature of knowledge through Fiat-Shamir transform？</title>
<link>https://crypto.stackexchange.com/questions/108221/can-a-sigma-protocol-be-transformed-into-a-signature-of-knowledge-through-fiat-s</link>
<guid>https://crypto.stackexchange.com/questions/108221/can-a-sigma-protocol-be-transformed-into-a-signature-of-knowledge-through-fiat-s</guid>
<content:encoded><![CDATA[

<p>As is well known, a sigma protocol can be transformed into a NIZK protocol through a Fiat-Shamir transform.</p>
<p>But can the Sigma protocol be transformed into a signature of knowledge in a similar manner?</p>
<p>Intuitively, it seems possible, but which research studies have directly proven this issue?</p>
]]></content:encoded>
<pubDate>2023-10-09T02:09:10Z</pubDate>
<pubDate>2024-06-06T07:08:16Z</pubDate>
</item>
<item>
<title>Does Schnorr identification protocol using commitment scheme?</title>
<link>https://crypto.stackexchange.com/questions/81187/does-schnorr-identification-protocol-using-commitment-scheme</link>
<guid>https://crypto.stackexchange.com/questions/81187/does-schnorr-identification-protocol-using-commitment-scheme</guid>
<content:encoded><![CDATA[

<p>In schnorr identification protocol, a prover needs to choose a random,let's say <span class="math-container">$r$</span> at the beginning, then commit to this randomness as <span class="math-container">$g^r\bmod p$</span>. When we say "commit", does it really mean we are using a commitment scheme?</p>

<p>if so, a commitment scheme needs to have binding and hiding properties. In this case I can get it is binding. But for hiding, it is not clear for me to see this property. Since the definition of hiding is adversary generate two messages <span class="math-container">$m_1,m_2$</span> and the adversary cannot distinguish their commitments. </p>
]]></content:encoded>
<pubDate>2020-06-05T08:31:01Z</pubDate>
<pubDate>2024-06-05T21:44:38Z</pubDate>
</item>
<item>
<title>Can ring signatures be considered as non interactive set membership proofs?</title>
<link>https://crypto.stackexchange.com/questions/111994/can-ring-signatures-be-considered-as-non-interactive-set-membership-proofs</link>
<guid>https://crypto.stackexchange.com/questions/111994/can-ring-signatures-be-considered-as-non-interactive-set-membership-proofs</guid>
<content:encoded><![CDATA[

<p>Can ring signatures be considered as non interactive set membership proofs?
For example, if the message <em>msg</em> is set to <em>null</em>, can the ring signature scheme proposed by Rivest et al. be regarded as a non interactive set membership proof scheme that satisfies zero knowledge and knowledge soundness?</p>
]]></content:encoded>
<pubDate>2024-06-03T18:11:07Z</pubDate>
<pubDate>2024-06-03T18:11:07Z</pubDate>
</item>
<item>
<title>Winner and individual vote counts in online voting in DRE-i and DRE-ip</title>
<link>https://crypto.stackexchange.com/questions/111609/winner-and-individual-vote-counts-in-online-voting-in-dre-i-and-dre-ip</link>
<guid>https://crypto.stackexchange.com/questions/111609/winner-and-individual-vote-counts-in-online-voting-in-dre-i-and-dre-ip</guid>
<content:encoded><![CDATA[

<p>I have seen few well-known related papers on online voting : <a href="https://www.usenix.org/system/files/conference/evtwote14/jets_0203-hao.pdf" rel="nofollow noreferrer">DRE-i</a>, <a href="https://eprints.whiterose.ac.uk/117997/1/DRE_ip.pdf" rel="nofollow noreferrer">DRE-ip</a> and <a href="https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;opi=89978449&amp;url=https://eprint.iacr.org/2018/466.pdf&amp;ved=2ahUKEwiQopTN6OOFAxVtUGwGHTYECToQFnoECBkQAQ&amp;usg=AOvVaw06rOVecSy9EoPVUbRR4DRU" rel="nofollow noreferrer">this one</a>.</p>
<p>They have explained most of the process such as vote casting and vote tallying. But I did not find when and where they have found which party has received how many votes and who wins.</p>
<p>I think I am missing something very basic. Can somebody point me where and how it is done in these papers?</p>
]]></content:encoded>
<pubDate>2024-04-28T02:08:39Z</pubDate>
<pubDate>2024-05-29T21:07:50Z</pubDate>
</item>
<item>
<title>Mask-Shuffle in Mental Poker Revisited from Barnett and Smart</title>
<link>https://crypto.stackexchange.com/questions/111928/mask-shuffle-in-mental-poker-revisited-from-barnett-and-smart</link>
<guid>https://crypto.stackexchange.com/questions/111928/mask-shuffle-in-mental-poker-revisited-from-barnett-and-smart</guid>
<content:encoded><![CDATA[

<p>I am going through the paper &quot;<a href="https://www.researchgate.net/profile/Igor-Shparlinski/publication/220963091_Periodic_Sequences_with_Maximal_Linear_Complexity_and_Almost_Maximal_k-Error_Linear_Complexity/links/0c96052af8b2672aae000000/Periodic-Sequences-with-Maximal-Linear-Complexity-and-Almost-Maximal-k-Error-Linear-Complexity.pdf#page=380" rel="nofollow noreferrer">Mental Poker Revisited</a>&quot; by Barnett and Smart.</p>
<p>I understood Section 5 in which the author explains Chaum-Pedersen (CP) protocol and how it is used in methods such as Key Generation, Verifiable Masking Protocol, Verifiable Remasking Protocol, Verifying Decryption Protocol and Joining the game.</p>
<p>I am somewhat unclear in understanding &quot;Mask-Shuffling the deck&quot; in section 4.2 which uses the zero-knowledge proof explained in Figure 1. This function is not explained the way methods in section 5 are explained. How, this method is to be concretized or implemented (similar to the way methods in section 5 are concretized or implemented). If required, how we will be using Chaum-Pedersen (CP) protocol here?</p>
<p>Please help me in understanding.</p>
]]></content:encoded>
<pubDate>2024-05-28T14:41:22Z</pubDate>
<pubDate>2024-05-29T03:48:31Z</pubDate>
</item>
<item>
<title>In groth16, how restricting public Inputs to the prime field instead of the snark scalar field can be used?</title>
<link>https://crypto.stackexchange.com/questions/111918/in-groth16-how-restricting-public-inputs-to-the-prime-field-instead-of-the-snar</link>
<guid>https://crypto.stackexchange.com/questions/111918/in-groth16-how-restricting-public-inputs-to-the-prime-field-instead-of-the-snar</guid>
<content:encoded><![CDATA[

<p>Recently <a href="https://github.com/iden3/snarkjs/commit/8035774be493ac09e322cd1335e1a1d0ea3979d9" rel="nofollow noreferrer">such an overflow was fixed in snarkjs</a> but given the small difference between the 2 and that it was restricted to the prime field anyway, how could this be exploited ?</p>
]]></content:encoded>
<pubDate>2024-05-27T14:10:47Z</pubDate>
<pubDate>2024-05-27T14:10:47Z</pubDate>
</item>
<item>
<title>which zero knowledge proof technique is suitable for identity verification system?</title>
<link>https://crypto.stackexchange.com/questions/108787/which-zero-knowledge-proof-technique-is-suitable-for-identity-verification-syste</link>
<guid>https://crypto.stackexchange.com/questions/108787/which-zero-knowledge-proof-technique-is-suitable-for-identity-verification-syste</guid>
<content:encoded><![CDATA[

<p>I am a beginner in the cryptographic field but as a graduation project, I have to build an identity verification and management system using zero-knowledge proofs.
I see a lot of zkp techniques, algorithms, and libraries. I got lost and concerned about its implementation complexity.</p>
<p>so, my question is, what are the recommended zkp techniques for my case?</p>
<ul>
<li>in my system, the client is allowed to prove some personal information to the verifier without disclosing it.</li>
<li>the system is a website.</li>
<li>I prefer to use a zkp technique that is an open-source, secure, private, and doesn't require a trusted set-up.</li>
<li>I prefer to implement a zkp technique that has comprehensive documentation.</li>
</ul>
<p>I appreciate and help and guidance, and thank you in advance.</p>
]]></content:encoded>
<pubDate>2023-11-25T20:31:47Z</pubDate>
<pubDate>2024-05-25T09:00:30Z</pubDate>
</item>
<item>
<title>Proof of knowledge and replay attacks</title>
<link>https://crypto.stackexchange.com/questions/58786/proof-of-knowledge-and-replay-attacks</link>
<guid>https://crypto.stackexchange.com/questions/58786/proof-of-knowledge-and-replay-attacks</guid>
<content:encoded><![CDATA[

<p>I was reading the ZK proof of knowledge of Schnorr and fiat shamir transformation, and I figured out that replay attacks are possible. Why these protocols don't take into account this attack? That seems very strange.</p>

<p>Thank you.</p>
]]></content:encoded>
<pubDate>2018-04-29T23:43:22Z</pubDate>
<pubDate>2024-05-21T23:16:25Z</pubDate>
</item>
<item>
<title>ZK is not preserved under parallel composition! - Witness Indistinguishability</title>
<link>https://crypto.stackexchange.com/questions/111473/zk-is-not-preserved-under-parallel-composition-witness-indistinguishability</link>
<guid>https://crypto.stackexchange.com/questions/111473/zk-is-not-preserved-under-parallel-composition-witness-indistinguishability</guid>
<content:encoded><![CDATA[

<p>Referring to an old but very nice paper on Witness Indistinguishability and Witness Hiding (<a href="https://courses.csail.mit.edu/6.885/spring05/papers/feigeshamir-stoc90.pdf" rel="nofollow noreferrer">link</a>).</p>
<p>On page 4, in theorem 3.2, the author explained it in three points, but I have few queries.</p>
<p>In point 2: &quot;he sends w to <span class="math-container">$\bar V$</span>, showing that he too knows w&quot;</p>
<p>Why is it required? What value it is adding?</p>
<p>In point 3: &quot;<span class="math-container">$\bar P$</span> proves his knowledge of w&quot;</p>
<p>But, <span class="math-container">$\bar P$</span> never had w, then how can it prove?</p>
<p>In next paragraph, he also explains how two parallel executions <span class="math-container">$(\bar P_1, \bar V)$</span> and <span class="math-container">$(\bar P_2, \bar V)$</span>.</p>
<p>But, since I could not grasp the earlier part, I am having hard time understanding this also.</p>
<p>Can somebody please provide more insight to this?</p>
]]></content:encoded>
<pubDate>2024-04-17T12:28:55Z</pubDate>
<pubDate>2024-05-18T08:03:35Z</pubDate>
</item>
<item>
<title>Is it safe to "sign" a message with such a zk proof</title>
<link>https://crypto.stackexchange.com/questions/109109/is-it-safe-to-sign-a-message-with-such-a-zk-proof</link>
<guid>https://crypto.stackexchange.com/questions/109109/is-it-safe-to-sign-a-message-with-such-a-zk-proof</guid>
<content:encoded><![CDATA[

<p>I am building an application in which I need to sign a message without revealing my entire identity.</p>
<p>To do so, I just compute a zk proof with the following purpose:</p>
<ul>
<li>prove I own the secret key <strong>sk</strong> associated with a public key <strong>pk</strong> (that matches some properties, e.g. <span class="math-container">$pk \in Authorized\_keys$</span>)</li>
<li>sign a message with <span class="math-container">$sig = H(sk|msg)$</span></li>
</ul>
<p>with <span class="math-container">$H$</span> a hash function.</p>
<ol>
<li><p>Is it safe ?</p>
</li>
<li><p>Should I use a more advance construction (such as <span class="math-container">$sig = H(sk \oplus opad, H(sk  \oplus ipad$</span>, msg)) to build a HMAC) ?</p>
</li>
</ol>
]]></content:encoded>
<pubDate>2023-12-19T11:01:58Z</pubDate>
<pubDate>2024-05-17T19:02:30Z</pubDate>
</item>
<item>
<title>Succinct proof of evaluation of known polynomial</title>
<link>https://crypto.stackexchange.com/questions/111838/succinct-proof-of-evaluation-of-known-polynomial</link>
<guid>https://crypto.stackexchange.com/questions/111838/succinct-proof-of-evaluation-of-known-polynomial</guid>
<content:encoded><![CDATA[

<p>Consider the <strong>zeroes polynomial</strong>
<span class="math-container">$$ 
zeroes_n(X) = \prod_{0\leq i&lt; n} (X-i) .
$$</span>
Fix a large prime <span class="math-container">$p$</span>, and fix some <span class="math-container">$n$</span> that is less than <span class="math-container">$p$</span> but which may still be very large (e.g. <span class="math-container">$p\approx 2^{256}$</span> and <span class="math-container">$n\approx 2^{64}$</span>).</p>
<p><strong>Question:</strong> What is the state of the art for a prover to succinctly prove to a verifier that
<span class="math-container">$$
zeroes_n(x) = y \quad (mod\ p) .
$$</span>
In more detail:</p>
<ol>
<li>The verifier sends <span class="math-container">$n$</span>, <span class="math-container">$p$</span>, and <span class="math-container">$x$</span> to the prover.</li>
<li>The prover (if honest) computes <span class="math-container">$y=zeroes_n(x)\ (mod\ p)$</span> and returns this value to the verifier, along with a succinct proof <span class="math-container">$C$</span> that <span class="math-container">$y$</span> is correct.</li>
<li>The verifier can, without too much computation (e.g. <span class="math-container">$O(1)$</span> or <span class="math-container">$O(log(n))$</span> or similar) use <span class="math-container">$C$</span> to verify that indeed <span class="math-container">$zeroes_n(x)=y\ (mod\, p)$</span>, without having to compute <span class="math-container">$zeroes_n(x)$</span> itself.</li>
</ol>
<p>Note that:</p>
<ul>
<li>Both prover and verifier know the polynomial <span class="math-container">$zeroes_n(X)$</span>.  In particular, the verifier knows that the roots of <span class="math-container">$zeroes_n(X)$</span> are <span class="math-container">$\{0,\dots,n-1\}$</span>.</li>
<li>Both prover and verifier know <span class="math-container">$n$</span>, <span class="math-container">$p$</span>, and <span class="math-container">$x$</span>.  Nothing is hidden here.</li>
<li>Even though the verifier has full knowledge of the above, the verifier may be limited in computational power or memory space, so it cannot compute <span class="math-container">$zeroes_n(x)$</span> itself.</li>
<li>This setup is similar to a polynomial commitment of course, but if we look at it like that then note that the prover is being asked to commit to an evaluation of a <em>known</em> polynomial.  Thus something like KZG as described in <a href="https://alinush.github.io/2020/05/06/kzg-polynomial-commitments.html#verifying-an-evaluation-proof" rel="nofollow noreferrer">https://alinush.github.io/2020/05/06/kzg-polynomial-commitments.html#verifying-an-evaluation-proof</a> does not obviously help, so far as I can tell, because in this verification the verifier only knows that <em>some</em> polynomial evaluates as described, but cannot force the prover to use a particular one (such as <span class="math-container">$zeroes_n(X)$</span>).</li>
</ul>
<p>Thank you.</p>
]]></content:encoded>
<pubDate>2024-05-17T18:53:35Z</pubDate>
<pubDate>2024-05-17T18:58:41Z</pubDate>
</item>
<item>
<title>Zero knowledge proof of a linear expression in the exponent</title>
<link>https://crypto.stackexchange.com/questions/111408/zero-knowledge-proof-of-a-linear-expression-in-the-exponent</link>
<guid>https://crypto.stackexchange.com/questions/111408/zero-knowledge-proof-of-a-linear-expression-in-the-exponent</guid>
<content:encoded><![CDATA[

<p>Alice sends to Bob a value <span class="math-container">$B$</span> in <span class="math-container">$\mathbb{G}$</span> a group of high order. There are distinct elements <span class="math-container">$h_1$</span> and <span class="math-container">$h_2$</span> of high order of <span class="math-container">$\mathbb{G}$</span>, and Alice wants to prove to Bob that she knows some values <span class="math-container">$b_1, b_2 \in \mathbb{Z}_q$</span> such that <span class="math-container">$B=h_1^{b_1}h_2^{b_2}$</span>.</p>
<p>I have found the following <a href="https://crypto.stackexchange.com/questions/48202/how-do-i-construct-and-use-the-okamoto-protocol-simulator/48206#48206">related post</a> (quite old and without answer), but I could not find any information about the mentioned Okamoto protocol.</p>
<p>1/ Is this kind of proof possible and what are the techniques used in the literature to construct such a zero knowledge proof of knowledge?</p>
<p>2/ Is the Okamoto protocol in the related post correct? Where can we find information about it?</p>
]]></content:encoded>
<pubDate>2024-04-12T14:13:18Z</pubDate>
<pubDate>2024-05-14T05:23:44Z</pubDate>
</item>
<item>
<title>Zero knowlede proof of linear relations</title>
<link>https://crypto.stackexchange.com/questions/111714/zero-knowlede-proof-of-linear-relations</link>
<guid>https://crypto.stackexchange.com/questions/111714/zero-knowlede-proof-of-linear-relations</guid>
<content:encoded><![CDATA[

<p>Suppose a prover publishes two perfectly hiding commitments for <span class="math-container">$s_1,s_2$</span>, i.e. two Pedersen commitments <span class="math-container">$C_1=g^{s_1}h^{r_1}$</span> and <span class="math-container">$C_2=g^{s_2}h^{r_2}$</span> such that <span class="math-container">$s_1,s_2,r_1,r_2$</span> are secret field elements. Suppose that there two public field elements <span class="math-container">$b_1, b_2$</span> that satisfy  <span class="math-container">$b_1=s_1*b_2+s_2$</span>. How to create a zero knowledge proof (or argument of knowledge) for such linear relation?</p>
]]></content:encoded>
<pubDate>2024-05-07T15:11:12Z</pubDate>
<pubDate>2024-05-07T15:36:08Z</pubDate>
</item>
<item>
<title>Is the PLONK paper incorrect? [duplicate]</title>
<link>https://crypto.stackexchange.com/questions/111705/is-the-plonk-paper-incorrect</link>
<guid>https://crypto.stackexchange.com/questions/111705/is-the-plonk-paper-incorrect</guid>
<content:encoded><![CDATA[

<p>I'm having some confuses while implementing the PLONK by following the instruction in the Plonk paper. Could someone please help me with it?</p>
<p>In step 6th of the &quot;Verifier preprocessed input&quot; phase, we have the formula as in the first screenshot, but when I use it, I couldn't make the code pass. Then I took a look at this article <a href="https://hackmd.io/@chaosma/ByBIElFno#Verify-Preprocessing" rel="nofollow noreferrer">https://hackmd.io/@chaosma/ByBIElFno#Verify-Preprocessing</a> then tried to change my code according to their formula to compute the L1, as in the second screenshot, and it worked (also look at several implementations and in all of them <span class="math-container">$w = 1$</span>. So my question is: Is the formula written in the paper incorrect or am I missing something?</p>
<p>Paper link: <a href="https://eprint.iacr.org/2019/953.pdf" rel="nofollow noreferrer">https://eprint.iacr.org/2019/953.pdf</a></p>
<p>Note: My question is essentially about why <span class="math-container">$w = 1$</span>.</p>
<p><a href="https://i.sstatic.net/2em8voM6.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.sstatic.net/2em8voM6.png" /></a>
<a href="https://i.sstatic.net/51DQkM9H.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.sstatic.net/51DQkM9H.png" /></a></p>
]]></content:encoded>
<pubDate>2024-05-06T11:47:47Z</pubDate>
<pubDate>2024-05-07T05:41:11Z</pubDate>
</item>
<item>
<title>Simulating physical envelops: Will commitments work in this case?</title>
<link>https://crypto.stackexchange.com/questions/111703/simulating-physical-envelops-will-commitments-work-in-this-case</link>
<guid>https://crypto.stackexchange.com/questions/111703/simulating-physical-envelops-will-commitments-work-in-this-case</guid>
<content:encoded><![CDATA[

<p>I want to simulate following physical activity in cryptography.</p>
<p>Person X has written integers 1, 2, ..., 10 in seperate paper slips. He needs to distribute these slips to 10 people without knowing which slip is given to whom. So, he purchase 10 similar envelops and puts one slip in each envelop. Once all slips are enveloped, he takes all envelops and threw them all in air to shuffle. Now he does not know which envelop contains which number. Now, he distributes these envelops to the 10 people.</p>
<p>I thought we can use commitments to simulate envelop process, but even if we use commitments, they will still be distinguishable and hence, person X can still map the nos to their respective commited envelops. Where I am missing here and if not commitment, which scheme can I use here?</p>
]]></content:encoded>
<pubDate>2024-05-06T04:25:15Z</pubDate>
<pubDate>2024-05-06T04:25:15Z</pubDate>
</item>
<item>
<title>Zero knowledge proof applied to a chess position</title>
<link>https://crypto.stackexchange.com/questions/110939/zero-knowledge-proof-applied-to-a-chess-position</link>
<guid>https://crypto.stackexchange.com/questions/110939/zero-knowledge-proof-applied-to-a-chess-position</guid>
<content:encoded><![CDATA[

<p>I know next to nothing about cryptography. From what I have understood, anything that is provable can be done so using a zero knowledge proof (the result seems to be known from the 1980's or so, by S. Micali &amp; al.)</p>
<p>Starting from a given chess position, I want to use zero knowledge proof for a Prover to convince a Verifier that the position contains at least a checkmate in one move. It is assumed that the Verifier doesn't calculate this from the known position.</p>
<p>Chess positions can be simplified to <a href="https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation#:%7E:text=Forsyth%E2%80%93Edwards%20Notation%20(FEN),Scottish%20newspaper%20journalist%20David%20Forsyth." rel="nofollow noreferrer">FEN chess notation</a>. Here is a chess position <code>6Q1/8/8/8/8/8/5K2/7k w - - 0 1</code> that contains 4 ways to checkmate Black's king within 1 move, so it satisfies the criterion.</p>
<p>From what I understand, I should now transform the problem into a 3 colors map problem. If I can do so and reduce the problem to &quot;if this map can be colored with 3 colors such that no colors are adjacent, then there is at least one checkmate in the given FEN&quot;. From there, I understand that the zero knowledge proof would be completed, as the Verifier could ask the Prover to reveal adjacent colors over and over (and the Prover would reset the choice of the coloring between each time).</p>
<p>How can I do this? How can I transform the FEN chess notation into a map, or a graph that would satisfy the conversion problem?</p>
]]></content:encoded>
<pubDate>2024-03-02T11:11:16Z</pubDate>
<pubDate>2024-05-05T03:08:50Z</pubDate>
</item>
<item>
<title>Prove with ZKP that I have encrypted a message $v + random\_number\cdot c$ given an RSA public key?</title>
<link>https://crypto.stackexchange.com/questions/107522/prove-with-zkp-that-i-have-encrypted-a-message-v-random-number-cdot-c-given</link>
<guid>https://crypto.stackexchange.com/questions/107522/prove-with-zkp-that-i-have-encrypted-a-message-v-random-number-cdot-c-given</guid>
<content:encoded><![CDATA[

<p>I want to create an application in which users can cast vote to blockchain in encrypted form using RSA. The private key will be revealed only after completion of the election.</p>
<p>My major use case is as follows:</p>
<ul>
<li>There will be certain number of candidates, <span class="math-container">$c$</span>. So voter has to choose a number from <span class="math-container">$1$</span> to c, lets say his choice is <span class="math-container">$v$</span>;</li>
<li>Encrypted votes will be: <span class="math-container">$ballot = v^e$</span>;</li>
<li>Since there are finitely small <span class="math-container">$v$</span>, <span class="math-container">$v^e$</span> is deterministic and anybody can determine the vote with a quick brute-force;</li>
<li>So I would like to introduce randomness by, <span class="math-container">$ballot = (v + random\_number \cdot c)^e$</span>;</li>
<li>I plan to remove randomness after decryption by: <span class="math-container">$(v + random\_number \cdot c) \bmod c = v$</span>.</li>
</ul>
<p>How is it possible to create a <em>zero knowledge proof</em> that I have honestly computed <span class="math-container">$(v + random\_number \cdot c)^e$</span>?</p>
<p>Any other solution such as one using zk-SNARK's would also be acceptable.</p>
]]></content:encoded>
<pubDate>2023-08-05T15:51:40Z</pubDate>
<pubDate>2024-05-04T12:05:25Z</pubDate>
</item>
<item>
<title>Equality check with Pedersen commitments</title>
<link>https://crypto.stackexchange.com/questions/111629/equality-check-with-pedersen-commitments</link>
<guid>https://crypto.stackexchange.com/questions/111629/equality-check-with-pedersen-commitments</guid>
<content:encoded><![CDATA[

<p>Does the Pedersen commitment scheme allow for checking whether two commitments are made - say by different people - for the same value?</p>
]]></content:encoded>
<pubDate>2024-04-29T14:03:04Z</pubDate>
<pubDate>2024-04-29T18:47:48Z</pubDate>
</item>

</channel>
</rss>